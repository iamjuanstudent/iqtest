/*
IqTest: A javascript testing framework that promises to be easy

(c) 2012 James Treworgy
MIT License
*/

(function(a){a(["./iqtest"],function(p,r,s,l,e,q){var m,o,b,i={name:"test-group",desc:"Unnamed Test Group",debug:false,showPassed:false,setup:null,teardown:null},n={name:"test",desc:"Unnamed Test",func:null,showPassed:false,timeoutSeconds:10,debug:false},f="same,equals,typeOf,defined,isNull,match,isObject,isFunction,exception,tagName,className,isTrue,isFalse",k=false,c={};
function d(v,u){var t=c[v.split(".")[1]].args;return t<u.length?String(u[t]):"an anonymous test";
}function g(w,u){var v=0,x=/^.*?Expected.*?([0-9]) argument[s]?\s*$/;try{u();}catch(t){v=x.test(t.message)?parseInt(RegExp.$1,10):0;
}c[w]={args:v};}function j(){var t,u;if(k){return;}l.push({truthy:function(w,v){p.expectOpts(arguments,1);
return{passed:!!w,err:p.formatAssert(v,"The object {0} is {not}truthy",String(w))};
},resolves:function(w,v){return{passed:typeof w!=="undefined",err:p.formatAssert(v,"The object {0} did {not}resolve",String(w))};
}});u=m.prototype;t=buster.assertions;p.each(["assert","refute"],function(w,x){var v={};
p.each(f.split(","),function(y,z){g(z,t[x][z]);v[z]=function(){var A=((this.test&&this.test instanceof m)?this.test:this);
return A.queueTest(t[x][z],x+"."+z,p.toArray(arguments));};});p.each(l,function(y,z){p.each(z,function(B,A){if(!v[B]){g(B,A);
v[B]=function(){var C=((this.test&&this.test instanceof m)?this.test:this);return C.queueBooleanTest(A,x+"."+B,p.toArray(arguments),x==="refute");
};}});});if(x==="assert"){p.extend(u,v);}p.each(["backpromise","callback","then"],function(y,z){v[z]=function(){return this.test[z].apply(this.test,p.toArray(arguments));
};});u[x]=function(z,y){return u[x].truthy.apply(this,p.toArray(arguments));};p.extend(u[x],v);
k=true;});}$.extend(p,{event:function(t,v,u){if(p.isFunction(t)){t.call(v,u);}},expectOpts:function(t,u){if((t?t.length:0)<u){throw ({name:"AssertionError",type:"iq",message:p.format("Expected to receive at least {0} argument",u.toString())});
}},formatAssert:function(t,v,u){return !v?"":(t?t+": ":"")+p.format(v,p.isArray(u)?u:p.toArray(arguments,2));
}});function h(u,t){if(u[t]){u[t].apply(this,p.toArray(arguments,2));}}o=function(u,t,v){j();
var w=u&&typeof u==="object"?u:t&&typeof t==="object"?t:v||{};if(typeof t==="string"){w.name=u;
}if(typeof t==="string"){w.desc=t;}p.extend(this,p.extend(null,i,w,true));this.clear();
};o.prototype={constructor:o,add:function(y){var w,v,u,z,x=this;function t(A){x.tests.push(A);
A.group=x;A.id=x.tests.length;}if(y.constructor===o){p.each(y.tests,function(B,A){t(A);
});}else{if(y.constructor===m){t(y);}else{if(typeof y==="string"){u=arguments[1];
v=arguments[2];w=!!v;z={name:y,desc:w?u:"",func:w?v:u,debug:x.debug,showPassed:x.showPassed};
t(new m(z));}}}return x;},run:function(){var t,u=this;h.call(this,this,"setup");p.each(u.tests,function(v,w){w.reset();
});p.event(u.groupStart,u,p.filterProps(u,"name,desc"));p.each(u.tests,function(x,z){var v=p.extend({},z.assert,{test:z}),y=p.extend({},z.refute,{test:z});
h.call(z,z,"setup");p.event(z.testStart,z,p.filterProps(z,"name"));if(z.debug){z.func.call(z,v,y);
}else{try{z.func.call(z,v,y);}catch(w){z.testerror(p.format("An error occurred in your test code: {0}",w),true);
}}z._lastPromise=z.promise;z._allPass=true;t=function(A){if(A.promise!==A._lastPromise){A._lastPromise=A.promise;
A._lastPromise.then(function(){t(A);},function(B){A.testerror(B,true);t(A);});return;
}if(!p.isBool(A.passed)){A.passed=(A.count===A.countPassed);}A._allPass&=A.passed;
p.event(A.testEnd,A,p.filterProps(A,"count,passed"));h.call(A,A,"teardown");if(A===u.tests[u.tests.length-1]){if(p.isBool(A.passed)){u.passed=A._allPass;
}p.event(u.groupEnd,u,p.filterProps(A,"passed"));h.call(this,this,"teardown");}};
z.promise.then(function(){t(z);},function(A){z.testerror(A,true);t(z);});});},then:function(v,t){if(p.isFunction(v)){this.promise=this.promise.then.apply(this.promise,p.toArray(arguments));
return this;}else{var u=new o(this);this.promise=this.promise.then(function(){u.test(v,t);
return u;},function(){alert("debug: failback called on a group");});return u;}},configure:function(u){if(typeof u==="string"){u={name:u};
}var t=p.extend({},i);p.extend(t,u,true);p.extend(this,t);return this;},reset:function(){this.promise=r.defer();
this.passed=null;return this;},clear:function(){this.tests=[];this.reset();return this;
},groupStart:p.donothing,groupEnd:p.donothing};m=function(u){var t=this;p.extend(t,n);
p.extend(t,u,true);t.id=null;t.group=null;t.reset();};m.prototype={constructor:m,impl:{},reset:function(){p.extend(this,{promise:r.defer(),results:[],count:0,countPassed:0,countFailed:0,debugCount:-1,nextThen:[],cbPromise:null,resolver:null,stopped:false,passed:null});
this.promise.resolve();},nextIsProblemAssertion:function(){return this.debug&&!this.stopped&&this.debugCount>=0&&this.debugCount===this.count-1;
},timeout:function(v){var t=this,u=t.timeoutSeconds;t.then(function(){t.timeoutSeconds=v;
});t.afterNext(function(){t.timeoutSeconds=u;});},configure:function(u){if(typeof u==="string"){u={name:u};
}var t=p.extend({},n);p.extend(t,this,u,true);p.extend(this,t);},then:function(t,v){var w=this,u=v||function(z){w.testerror(z,false);
},y=w.promise,x=r.defer();x.then(function(){try{if(w.nextIsProblemAssertion()){;}t();
}catch(z){w.testerror("An error occurred during a 'then' clause of an assertion: "+String(z),true);
}},u);w.promise=x;r.chain(y,x);return w;},afterNext:function(t,u){this.nextThen.push({callback:t,errback:u});
},startTest:function(t){this.count++;p.event(this.itemStart,this,p.extend({},t,{count:this.count}));
this.itemRunning=true;},endTest:function(u){var t=u;if(!this.itemRunning){this.testerror("Error: test was not running when endTest called: "+u.desc);
return;}if(!u.passed){t=this.addResult(u);this.countFailed++;}else{this.countPassed++;
}this.itemRunning=false;p.event(this.itemEnd,this,t);},queueBooleanTest:function(w,u,t,v){return this.queueTest(function(){var x=w.apply(null,p.toArray(arguments));
if(x.passed===v){throw ({name:"AssertionError",type:"iq",message:p.format(x.err.replace("{not}","{0}"),v?"not ":"")});
}},u,t);},queueTest:function(B,u,t){var z=this,w,v=u.split(".")[1],A=c[v].args,y,x,C,E,D=[];
if(z.stopped){return z;}if(z.cbPromise){y=true;x=x||r.defer();if(A===1){w=0;}else{if(t[0]&&!t[1]){w=1;
}else{if(t[1]&&!t[0]){w=0;}else{z.testerror(p.format("I couldn't figure out what to do with your magic callback. For this test you may need to define it explicitly.[{0}] {1}",u,d(t)));
return;}}}z.cbPromise.then(function(H){t[w]=H;},function(H){x.reject("The callback failed. "+(H?p.format("Reason: {0}",String(H)):""));
});D.push(z.cbPromise);z.cbPromise=null;}if(v==="resolves"&&!r.isPromise(t[0])){throw ("The argument passed to 'resolves' was not a promise.");
}p.each(t,function(I,H){if(r.isPromise(H)){x=x||r.defer();if(I===0&&y){x.reject("You're using magic callback but you've also defined a promise as the first argument of your assert.");
}H.then(function(J){t[I]=J;});D.push(H);}});z.then(function(){z.startTest({desc:d(u,t),assertion:u});
});if(D.length){D.push(z.promise);z.promise=z.timeoutSeconds?s(x.promise,z.timeoutSeconds*1000):x.promise;
r.chain(r.all(D),x);}C=r.defer();E=z.promise;z.promise=C.promise;E.then(function G(H){if(z.runTest.call(z,B,u,t)){C.resolve();
}else{C.reject("The test failed");}},function F(H){if(z.itemRunning){z.endTest({passed:false,desc:String(H)});
}});return z;},runTest:function(w,u,t){var x={assertion:u,err:"",passed:true};try{w.apply(null,t);
}catch(v){if(v.name!=="AssertionError"){if(this.debug){;w.apply(null,t);}else{this.debug=true;
v.message=(v.message||v.type)+". Debugging has been enabled.";}}if(v.type==="iq"){v.message=p.format("[{0}] {1}",u,v.message);
}x.err=v.message;x.passed=false;}this.endTest(x);return x.passed;},addResult:function(v){var u=p.extend({},v),t=u.passed?"passed":"failed";
u.count=this.count;u.fulltext=p.format("Test #{0} {1}{2}{3}",this.count,t,u.passed?"":": "+v.err,v.desc?p.format(' in test "{0}"',v.desc):"");
this.results.push(u);return u;},testerror:function(u,t){var v=this;if(v.stopped){return;
}v.debugCount=v.count;v.stopped=true;v.passed=false;p.event(v.log,v.group,p.format("{0}. {1}",String(u),t?"Debugging is enabled if you start again.":""));
if(t){v.debug=true;}},callback:function(x,y){var v=this,w=y||v.timeoutSeconds,u=r.defer();
v.cbPromise=w?s(u,w*1000):u;return function(){var z;if(!x){z=true;}else{if(v.debug){z=x.apply(this,p.toArray(arguments));
}else{try{z=x.apply(this,p.toArray(arguments));}catch(t){v.testerror("An error occurred in your callback(): "+String(t),true);
u.reject(z);return;}}}u.resolve(z);};},backpromise:function(y,u,B){var w=r.defer(),z=this,A=B||z.timeoutSeconds,v=function(){var C;
if(z.debug){C=u.apply(this,p.toArray(arguments));}else{try{C=u.apply(this,p.toArray(arguments));
}catch(t){z.testerror("An error occurred in your backpromise() callback: "+t,true);
w.reject(C);return;}}w.resolve(C);};if(z.debug){y.call(z,v);}else{try{y.call(z,v);
}catch(x){z.testerror("An error occurred in your backpromise() function: "+x,true);
w.reject();return;}}return A?s(w,A*1000):w;},testStart:p.donothing,testEnd:p.donothing,itemStart:p.donothing,itemEnd:p.donothing,log:p.donothing};
return{create:function(v,t,w){var u=new o(v,t,w);return u;},add:function(){return this.add.apply(this,p.toArray(arguments));
},extend:function(t){l.push(t);},impl:{TestGroup:o,Test:m,Assert:b,utility:p}};});
}(typeof define==="function"?define:function(a,b){if(typeof module!=="undefined"){module.exports=b(require("./when"),require("./timeout"),require("./buster-assertions"),require("./trewtech.utils"));
}else{if(!this.iqtest_assertions){this.iqtest_assertions=[];}this.iqtest=b(this.common.utils,this.when,this.when_timeout,this.iqtest_assertions,this.buster?this.buster.assert:null);
}}));