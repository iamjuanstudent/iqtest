/*
IqTest: A javascript testing framework that promises to be easy

(c) 2012 James Treworgy
MIT License
*/

(function(a){a(["./iqtest"],function(w,y,z,p,e,x){var q,r,v,b,l={name:"test-group",desc:"Unnamed Test Group",debug:false,timeout:10,setup:null,teardown:null},s={name:"test",desc:"Unnamed Test",func:null,timeout:10,debug:false},f="same,equals,typeOf,defined,isNull,match,isObject,isFunction,exception,tagName,className,isTrue,isFalse",o=false,c={};
function d(B,A){var u=c[B.split(".")[1]].args;return u<A.length?String(A[u]):"an anonymous test";
}function g(C,A){var B=0,D=/^.*?Expected.*?([0-9]) argument[s]?\s*$/;try{A();}catch(u){B=D.test(u.message)?parseInt(RegExp.$1,10):0;
}c[C]={args:B};}function n(){var u,A;if(o){return;}p.push({truthy:function(C,B){w.expectOpts(arguments,1);
return{passed:!!C,err:w.formatAssert(B,"The object {0} is {not}truthy",String(C))};
},resolves:function(C,B){w.expectOpts(arguments,1);return{passed:typeof C!=="undefined",err:w.formatAssert(B,"The object {0} did {not}resolve",String(C))};
}});A=r.prototype;u=buster.assertions;w.each(["assert","refute"],function(C,D){var B={};
w.each(f.split(","),function(E,F){g(F,u[D][F]);B[F]=function(){var G=((this.test&&this.test instanceof r)?this.test:this);
return G.queueTest(u[D][F],D+"."+F,w.toArray(arguments));};});w.each(p,function(E,F){w.each(F,function(H,G){if(!B[H]){g(H,G);
B[H]=function(){var I=((this.test&&this.test instanceof r)?this.test:this);return I.queueBooleanTest(G,D+"."+H,w.toArray(arguments),D==="refute");
};}});});if(D==="assert"){w.extend(A,B);}w.each(["backpromise","callback","then"],function(E,F){B[F]=function(){return this.test[F].apply(this.test,w.toArray(arguments));
};});A[D]=function(F,E){return A[D].truthy.apply(this,w.toArray(arguments));};w.extend(A[D],B);
o=true;});}$.extend(w,{event:function(u,B,A){if(w.isFunction(u)){u.call(B,A);}},expectOpts:function(u,A){if((u?u.length:0)<A){throw ({name:"AssertionError",type:"iq",message:w.format("Expected to receive at least {0} argument",A.toString())});
}},formatAssert:function(u,B,A){return !B?"":(u?u+": ":"")+w.format(B,w.isArray(A)?A:w.toArray(arguments,2));
}});function i(A,u){if(A[u]){A[u].apply(this,w.toArray(arguments,2));}}function h(A,u){function B(){return A.apply(this,u);
}B.prototype=A.prototype;return new B();}function k(E){var C,B,A,F,D=this;function u(G){D.tests.push(G);
G.group=D;G.id=D.tests.length;}if(E.constructor===v){w.each(E.tests,function(H,G){u(G);
});}else{if(E.constructor===r){u(E);}else{if(typeof E==="string"){A=arguments[1];
B=arguments[2];C=!!B;F={name:E,desc:C?A:"",func:C?B:A,debug:D.debug,timeout:D.timeout};
u(new r(F));}}}return D;}function t(u,B){var A;if(B.promise!==B._lastPromise){B._lastPromise=B.promise;
B._lastPromise.then(function(){t(u,B);},function(C){B.testerror(C,true);t(u,B);});
return;}if(!w.isBool(B.passed)){B.passed=(B.count===B.countPassed);}B._allPass&=B.passed;
B.doWriterEvent("testEnd",w.filterProps(B,"count,passed"));i.call(B,B,"teardown");
A=true;w.each(u.tests,function(D,C){if(!w.isBool(C.passed)){A=null;return false;}else{if(!C.passed){A=false;
}}});if(w.isBool(A)){u.passed=A;u.doWriterEvent("groupEnd");i.call(this,this,"teardown");
u.promise.resolve();}}function m(){var u=this;i.call(this,this,"setup");w.each(u.tests,function(A,B){B.reset();
});this.doWriterEvent("groupStart",w.filterProps(u,"name,desc"));w.each(u.tests,function(C,E){var A=w.extend({},E.assert,{test:E}),D=w.extend({},E.refute,{test:E});
i.call(E,E,"setup");E.doWriterEvent("testStart",w.filterProps(E,"name"));if(E.debug){E.func.call(E,A,D);
}else{try{E.func.call(E,A,D);}catch(B){E.testerror(w.format("An error occurred in your test code: {0}",B),true);
}}E._lastPromise=E.promise;E._allPass=true;E.promise.then(function(){t(u,E);},function(F){E.testerror(F,true);
t(u,E);});});}function j(A,u){var B=this;w.each(this.group.writers,function(D,C){var E=C[A];
if(w.isFunction(E)){E.apply(C,[B].concat(u));}});}v=function(A,u,B){n();var C=A&&typeof A==="object"?A:u&&typeof u==="object"?u:B||{};
if(typeof u==="string"){C.name=A;}if(typeof u==="string"){C.desc=u;}w.extend(this,w.extend(null,l,C,true));
this.writers=[];this.doEvent=i;this.group=this;this.doWriterEvent=function(){j.apply(this,w.toArray(arguments));
};this.clear();};v.prototype={constructor:v,add:k,run:m,then:function(){return this.promise.then;
},configure:function(A){if(typeof A==="string"){A={name:A};}var u=w.extend({},l);
w.extend(u,A,true);w.extend(this,u);return this;},reset:function(){this.promise=y.defer();
this.passed=null;return this;},clear:function(){this.tests=[];this.reset();return this;
},writer:function(u){var B,A=q.writers[u];if(!A){throw ("There is no output writer with id '{0}'".format(B));
}B=h(A,w.toArray(arguments,1));B.owner=this;this.writers.push(B);return this;},groupStart:w.donothing,groupEnd:w.donothing};
r=function(A){var u=this;w.extend(u,s);w.extend(u,A,true);u.id=null;u.group=null;
u.reset();this.doWriterEvent=function(){j.apply(this,w.toArray(arguments));};};r.prototype={constructor:r,impl:{},reset:function(){w.extend(this,{promise:y.defer(),results:[],count:0,countPassed:0,countFailed:0,nextThen:[],cbPromise:null,resolver:null,stopped:false,passed:null});
this.setDebug(false);this.promise.resolve();},setDebug:function(u,A){this.debug=w.isBool(u)?u:true;
y.debug=this.debug;if(u){if(typeof A==="number"){this.debugCount=A;}}else{this.debugCount=-1;
}},nextIsProblemAssertion:function(){return this.debug&&!this.stopped&&this.debugCount>=0&&this.debugCount===this.count-1;
},timeoutOnce:function(B){var u=this,A=u.timeout;u.then(function(){u.timeout=B;});
u.afterNext(function(){u.timeout=A;});},configure:function(A){if(typeof A==="string"){A={name:A};
}var u=w.extend({},s);w.extend(u,this,A,true);w.extend(this,u);},then:function(u,B){var C=this,A=B||function(F){C.testerror(F,false);
},E=C.promise,D=y.defer();C.promise=D;E.then(function(){try{if(C.nextIsProblemAssertion()){;
}u();}catch(F){C.testerror("An error occurred during a 'then' clause of an assertion: "+String(F),true);
}},A);y.chain(E,D);return C;},chain:function(u,A){var B=y.defer(),C=this.promise;
this.promise=B.promise;C.then(u,A||this.testerror);y.chain(C,B);},afterNext:function(u,A){this.nextThen.push({callback:u,errback:A});
},startTest:function(u){this.count++;this.assertionInfo=w.extend({},u,{count:this.count});
this.doWriterEvent("itemStart",this.assertionInfo);this.itemRunning=true;},endTest:function(A){var u=A;
if(!this.itemRunning){this.testerror("Error: test was not running when endTest called: "+A.desc);
return;}if(!A.passed){u=this.addResult(A);this.countFailed++;}else{this.countPassed++;
}this.itemRunning=false;this.doWriterEvent("itemEnd",u);},queueBooleanTest:function(C,A,u,B){return this.queueTest(function(){var D=C.apply(null,w.toArray(arguments));
if(D.passed===B){throw ({name:"AssertionError",type:"iq",message:w.format(D.err.replace("{not}","{0}"),B?"not ":"")});
}},A,u);},queueTest:function(H,A,u){var F=this,C,B=A.split(".")[1],G=c[B].args,E,D,I,K,J=[];
if(F.stopped){return F;}if(F.cbPromise){E=true;D=D||y.defer();if(G===1){C=0;}else{if(u[0]&&!u[1]){C=1;
}else{if(u[1]&&!u[0]){C=0;}else{F.testerror(w.format("I couldn't figure out what to do with your magic callback. For this test you may need to define it explicitly.[{0}] {1}",A,d(u)));
return;}}}F.cbPromise.then(function(N){u[C]=N;},function(N){D.reject("The callback failed. "+(N?w.format("Reason: {0}",String(N)):""));
});J.push(F.cbPromise);F.cbPromise=null;}if(B==="resolves"&&!y.isPromise(u[0])){throw ("The argument passed to 'resolves' was not a promise.");
}w.each(u,function(O,N){if(y.isPromise(N)){D=D||y.defer();if(O===0&&E){D.reject("You're using magic callback but you've also defined a promise as the first argument of your assert.");
}N.then(function(P){u[O]=P;});J.push(N);}});this.chain(function(){F.startTest({desc:d(A,u),assertion:A});
});if(J.length){J.push(F.promise);F.promise=F.timeout?z(D.promise,F.timeout*1000):D.promise;
y.chain(y.all(J),D);}I=y.defer();K=F.promise;F.promise=I.promise;K.then(function M(N){if(F.runTest.call(F,H,A,u)){I.resolve();
}else{I.reject("The test failed");}},function L(N){if(F.itemRunning){F.endTest({passed:false,desc:String(N)});
}I.reject("The test was stopped because an assertion failed.");});return F;},runTest:function(C,A,u){var D={assertion:A,err:"",passed:true};
try{C.apply(null,u);}catch(B){if(B.name!=="AssertionError"){if(this.debug){;C.apply(null,u);
}else{this.setDebug();B.message=(B.message||B.type)+". Debugging has been enabled.";
}}if(B.type==="iq"){B.message=w.format("[{0}] {1}",A,B.message);}D.err=B.message;
D.passed=false;}this.endTest(D);return D.passed;},addResult:function(B){var u=w.extend({},B),A=u.passed?"passed":"failed";
u.count=this.count;u.fulltext=w.format("Test #{0} {1} {2} {3}{4}",this.count,this.assertionInfo.assertion,A,u.passed?"":": "+B.desc,w.format(' in test "{0}"',this.assertionInfo.desc));
this.results.push(u);return u;},testerror:function(A,u){var B=this;if(B.stopped){return;
}B.stopped=true;B.passed=false;this.doWriterEvent("testLog",w.format("{0}. {1}",String(A),u?"Debugging is enabled if you start again.":""));
if(u){B.setDebug(true,B.count);}},callback:function(C,D){var A=this,B=D||A.timeout,u=y.defer();
A.cbPromise=B?z(u,B*1000):u;return function(){var F;if(!C){F=true;}else{if(A.debug){F=C.apply(this,w.toArray(arguments));
}else{try{F=C.apply(this,w.toArray(arguments));}catch(E){A.testerror("An error occurred in your callback(): "+String(E),true);
u.reject(F);return;}}}u.resolve(F);};},backpromise:function(D,u,G){var B=y.defer(),E=this,F=G||E.timeout,A=function(){var I;
if(E.debug){I=u.apply(this,w.toArray(arguments));}else{try{I=u.apply(this,w.toArray(arguments));
}catch(H){E.testerror("An error occurred in your backpromise() callback: "+H,true);
B.reject(I);return;}}B.resolve(I);};if(E.debug){D.call(E,A);}else{try{D.call(E,A);
}catch(C){E.testerror("An error occurred in your backpromise() function: "+C,true);
B.reject();return;}}return F?z(B,F*1000):B;}};q={create:function(B,u,C){var A=new v(B,u,C);
return A;},add:function(){return this.add.apply(this,w.toArray(arguments));},extend:function(u){p.push(u);
},writers:{},impl:{TestGroup:v,Test:r,Assert:b,utility:w}};return q;});}(typeof define==="function"?define:function(a,b){if(typeof module!=="undefined"){module.exports=b(require("./when"),require("./timeout"),require("./buster-assertions"),require("./trewtech.utils"));
}else{if(!this.iqtest_assertions){this.iqtest_assertions=[];}this.iqtest=b(this.common.utils,this.when,this.when_timeout,this.iqtest_assertions,this.buster?this.buster.assert:null);
}}));