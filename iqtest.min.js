/*
IqTest: A javascript testing framework that promises to be easy

(c) 2012 James Treworgy
MIT License
*/

(function(a){a(["./iqtest"],function(o,p,i,d){var n,h=false,e="same,equals,typeOf,defined,isNull,match,isObject,isFunction,exception,tagName,className",j,l,b,f={name:"Unnamed Test Group",debug:false},k={name:"",desc:"Unnamed Test",func:null,timeoutSeconds:10,debug:false};
function m(s,q,r){var t=s.apply(null,q);if(t.passed===r){throw ({name:"AssertionError",type:"iq",message:n.format(t.err,r?"not":"")});
}}function c(q){return q.length>0&&typeof q[q.length-1]==="string"?q[q.length-1]:"";
}function g(){var q,r;if(h){return;}i.push({truthy:function(s){return{passed:!!s,err:n.format("The object {0} is {not}truthy",s.toString()).replace("{not}","{0}")};
}});r=j.prototype;q=buster.assertions;n.each(["assert","refute"],function(t,u){var s={};
n.each(e.split(","),function(v,w){s[w]=function(){var x=(this.testObject||this);return x.queueTest(q[u][w],u+"."+w,n.toArray(arguments));
};});n.each(i,function(v,w){n.each(w,function(y,x){if(!s[y]){s[y]=function(){var z=(this.testObject||this);
return z.queueTest(m,u+"."+y,[x,n.toArray(arguments),u==="concat"]);};}});});if(u==="assert"){n.extend(r,s);
}n.each(["backpromise","callback","then"],function(v,w){s[w]=function(){return this.testObject[w].apply(this.testObject,n.toArray(arguments));
};});r[u]=function(w,v){return r[u].truthy.apply(this,n.toArray(arguments));};n.extend(r[u],s);
h=true;});}n={extend:function(y){var v,w,x,q,t=arguments.length,r=typeof arguments[t-1]==="boolean",s=r?t-2:t-1,u=r?arguments[s+1]:false;
x=n.toArray(arguments,1,s+1);for(q=0;q<x.length;q++){w=x[q];for(v in w){if(w.hasOwnProperty(v)&&(!u||y.hasOwnProperty(v))){y[v]=w[v];
}}}return y;},filter:function(r,t){var s={},q=n.isArray(t)?t:t.split(",");n.each(q,function(u,v){s[v]=r[v];
});return s;},toArray:function(q,r,s){return Array.prototype.slice.call(q,r||0,s);
},isArray:function(q){return q&&q.constructor===Array;},isFunction:function(q){return typeof q==="function";
},format:function(r){var q=(arguments.length===2&&n.isArray(arguments[1]))?arguments[1]:this.toArray(arguments,1);
return r.replace(/\{(\d+)\}/g,function(s,t){return typeof q[t]!=="undefined"?String(q[t]):s;
});},each:function(r,q){var s;if(n.isArray(r)){for(s=0;s<r.length;s++){if(q.call(r[s],s,r[s])===false){break;
}}}else{for(s in r){if(r.hasOwnProperty(s)){if(q.call(r[s],s,r[s])===false){break;
}}}}},event:function(q,s,r){if(n.isFunction(q)){q.call(s,r);}},donothing:function(){}};
l=function(q){g();this.tests=[];n.extend(this,f);n.extend(this,q,true);this.promise=o.defer();
this.passed=null;};l.prototype={constructor:l,test:function(u,q,r){var t=this,s=!!r,w={name:u,desc:s?q:"",func:s?r:q,debug:t.debug},v=new j(w);
t.tests.push(v);v.group=t;v.id=t.tests.length;return t;},run:function(u,q,s){var r,t=this;
n.event(t.groupStart,t,n.filter(t,"name,desc"));n.each(t.tests,function(w,x){x.reset();
n.event(x.testStart,x,n.filter(x,"name"));if(x.debug){x.func.call(x,x.assert,x.refute);
}else{try{x.func.call(x,x.assert,x.refute);}catch(v){x.testerror(n.format("An error occurred in your test code: {0}",v),true);
}}x._lastPromise=x.promise;x._allPass=true;r=function(){if(x.promise!==x._lastPromise){x._lastPromise=x.promise;
x._lastPromise.then(r,r);return;}if(typeof x.passed!=="boolean"){x.passed=(x.count===x.countPassed);
}x._allPass&=x.passed;n.event(x.testEnd,x,n.filter(x,"count,passed"));if(x===t.tests[t.tests.length-1]){if(typeof t.passed!=="boolean"){t.passed=x._allPass;
}n.event(t.groupEnd,t,n.filter(x,"passed"));}};x.promise.then(r,r);});},then:function(s,q){if(n.isFunction(s)){this.promise=this.promise.then.apply(this.promise,n.toArray(arguments));
return this;}else{var r=new l(this);this.promise=this.promise.then(function(){r.test(s,q);
return r;},function(){alert("debug: failback called on a group");});return r;}},configure:function(r){var q=n.extend({},f);
n.extend(q,r,true);n.extend(this,q);return this;},groupStart:n.donothing,groupEnd:n.donothing};
j=function(r){var q=this;g();n.extend(q,k);n.extend(q,r,true);q.id=null;q.group=null;
q.reset();q.assert.testObject=q.refute.testObject=this;};j.prototype={constructor:j,impl:{},reset:function(){n.extend(this,{promise:o.defer(),results:[],count:0,countPassed:0,countFailed:0,nextThen:[],cbPromise:null,resolver:null,stopped:false,passed:null});
this.promise.resolve();},timeout:function(s){var q=this,r=q.timeoutSeconds;q.then(function(){q.timeoutSeconds=s;
});q.afterNext(function(){q.timeoutSeconds=r;});},configure:function(r){var q=n.extend({},k);
n.extend(q,this,r,true);n.extend(this,q);},then:function(q,s){var u=this,t=function(v){u.testerror(v,false);
};function r(v,w){u.promise=u.promise.then(v,w||t);}r(q,s);if(u.afterNext.length>0){n.each(function(v,w){r(w.callback,w.errback);
});u.afterNext=[];}return u;},afterNext:function(q,r){this.nextThen.push({callback:q,errback:r});
},startTest:function(q){this.count++;n.event(this.itemStart,this,n.extend({},q,{count:this.count}));
this.itemRunning=true;},endTest:function(r){var q=r;if(!r.passed){q=this.addResult(r);
this.countFailed++;}else{this.countPassed++;}this.itemRunning=false;n.event(this.itemEnd,this,q);
},queueTest:function(x,r,q){var w=this,z,s=x===m?q[1]:q,t,v,u=o.defer(),y=[];z=function(){if(w.runTest.call(w,x,r,q)){u.resolve();
}else{u.reject("The test failed.");}};w.promise.then(function(){w.startTest({desc:c(s),assertion:r});
},function(A){u.reject(A);});if(w.cbPromise){v=true;if(s.length===1){t=0;}else{if(s[0]&&!s[1]){t=1;
}else{if(s[1]&&!s[0]){t=2;}else{w.testerror(n.format("I couldn't figure out what to do with your magic callback. For this test you may need to define it explicitly.[{0}] {1}",r,c(s)));
return;}}}w.cbPromise.then(function(A){s[t]=A;},function(A){u.reject("The callback failed. "+A?n.format("Reason: {0}",A.toString()):"");
});y.push(w.cbPromise);w.cbPromise=null;}n.each(s,function(B,A){if(o.isPromise(A)){if(B===0&&v){u.reject("You're using magic callback but you've also defined a promise as the first argument of your assert.");
}A.then(function(C){s[B]=C;});y.push(A);}});if(y.length){y.push(w.promise);w.promise=o.all(y);
}w.then(z,function(A){u.reject(A);});w.promise=p(u.promise,w.timeoutSeconds*1000);
w.resolver=u.resolver;return w;},runTest:function(t,r,q){var u={assertion:r,err:"",passed:true};
try{t.apply(null,q);}catch(s){if(s.name!=="AssertionError"){if(this.debug){;}else{this.debug=true;
s.message=(s.message||s.type)+". Debugging has been enabled.";}}if(s.type==="iq"){s.message=n.format("[{0}] {1}",r,s.message);
}u.err=s.toString();u.passed=false;}this.endTest(u);return u.passed;},addResult:function(s){var r=n.extend({},s),q=r.passed?"passed":"failed";
r.count=this.count;r.fulltext=n.format("Test #{0} {1}{2}{3}",this.count,q,r.passed?"":": "+s.err,s.desc?n.format(' in test "{0}"',s.desc):"");
this.results.push(r);return r;},testerror:function(r,q){var t=this;if(t.resolver){try{t.resolver.reject(r);
}catch(s){}t.resolver=null;}if(t.stopped){return;}t.stopped=true;t.passed=false;n.event(t.log,t.group,n.format("{0}. {1}",r.toString(),q?"Debugging is enabled if you start again.":""));
if(q){t.debug=true;}},callback:function(s,t){var r=this,q=o.defer();r.cbPromise=t?p(q,t*1000):q;
return function(){var v;if(!s){v=true;}else{if(r.debug){v=s.apply(r,n.toArray(arguments));
}else{try{v=s.apply(r,n.toArray(arguments));}catch(u){r.testerror("An error occurred in your callback(): "+u,true);
q.reject(v);return;}}}q.resolve(v);};},backpromise:function(u,q,w){var s=o.defer(),v=this,r=function(){var y;
if(v.debug){y=q.apply(this,n.toArray(arguments));}else{try{y=q.apply(this,n.toArray(arguments));
}catch(x){v.testerror("An error occurred in your backpromise() callback: "+x,true);
s.reject(y);return;}}s.resolve(y);};if(v.debug){u.call(v,r);}else{try{u.call(v,r);
}catch(t){v.testerror("An error occurred in your backpromise() function: "+t,true);
s.reject();return;}}return w?p(s,w*1000):s;},testStart:n.donothing,testEnd:n.donothing,itemStart:n.donothing,itemEnd:n.donothing,log:n.donothing};
return{test:function(){var q=new l(this);return q.test.apply(q,n.toArray(arguments));
},extend:function(q){i.push(q);},impl:{TestGroup:l,Test:j,Assert:b,utility:n}};});
}(typeof define==="function"?define:function(a,b){if(typeof module!=="undefined"){module.exports=b(require("./when"),require("./timeout"),require("./buster-assertions"));
}else{if(!this.iqtest_assertions){this.iqtest_assertions=[];}this.iqtest=b(this.when,this.when_timeout,this.iqtest_assertions,this.buster?this.buster.assert:null);
}}));