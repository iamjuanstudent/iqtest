/*
IqTest: A javascript testing framework that promises to be easy

(c) 2012 James Treworgy
MIT License
*/

(function(a){a(["./iqtest"],function(o,q,r,k,e,p){var l,n,b,h={name:"Unnamed Test Group",debug:false,showPassed:false},m={name:"",desc:"Unnamed Test",func:null,showPassed:false,timeoutSeconds:10,debug:false},f="same,equals,typeOf,defined,isNull,match,isObject,isFunction,exception,tagName,className,isTrue,isFalse",j=false,c={};
function d(u,t){var s=c[u.split(".")[1]].args;return s<t.length?String(t[s]):"an anonymous test";
}function g(v,t){var u=0,w=/^.*?Expected.*?([0-9]) argument[s]?\s*$/;try{t();}catch(s){u=w.test(s.message)?parseInt(RegExp.$1,10):0;
}c[v]={args:u};}function i(){var s,t;if(j){return;}k.push({truthy:function(v,u){o.expectOpts(arguments,1);
return{passed:!!v,err:o.formatAssert(u,"The object {0} is {not}truthy",String(v))};
},resolves:function(v,u){return{passed:typeof v!=="undefined",err:o.formatAssert(u,"The object {0} did {not}resolve",String(v))};
}});t=l.prototype;s=buster.assertions;o.each(["assert","refute"],function(v,w){var u={};
o.each(f.split(","),function(x,y){g(y,s[w][y]);u[y]=function(){var z=((this.test&&this.test instanceof l)?this.test:this);
return z.queueTest(s[w][y],w+"."+y,o.toArray(arguments));};});o.each(k,function(x,y){o.each(y,function(A,z){if(!u[A]){g(A,z);
u[A]=function(){var B=((this.test&&this.test instanceof l)?this.test:this);return B.queueBooleanTest(z,w+"."+A,o.toArray(arguments),w==="refute");
};}});});if(w==="assert"){o.extend(t,u);}o.each(["backpromise","callback","then"],function(x,y){u[y]=function(){return this.test[y].apply(this.test,o.toArray(arguments));
};});t[w]=function(y,x){return t[w].truthy.apply(this,o.toArray(arguments));};o.extend(t[w],u);
j=true;});}o={extend:function(B){var y,z,A,t,w=arguments.length,u=o.isBool(arguments[w-1]),v=u?w-2:w-1,s=!B,x=u?arguments[v+1]:false;
B=B||{};A=o.toArray(arguments,1,v+1);for(t=0;t<A.length;t++){z=A[t];for(y in z){if(z.hasOwnProperty(y)&&(s||!x||B.hasOwnProperty(y))){B[y]=z[y];
}}s=false;}return B;},filter:function(t,v){var u={},s=o.isArray(v)?v:v.split(",");
o.each(s,function(w,x){u[x]=t[x];});return u;},toArray:function(s,t,u){return Array.prototype.slice.call(s,t||0,u);
},isArray:function(s){return s&&s.constructor===Array;},isFunction:function(s){return typeof s==="function";
},isString:function(s){return typeof s==="string";},isBool:function(s){return typeof s==="boolean";
},trim:function(s){return s.replace(/^\s\s*/,"").replace(/\s\s*$/,"");},split:function(u,s){var t=[];
o.each(u.split(u,s),function(w,v){t.push(o.trim(v));});return t;},format:function(t){var s=(arguments.length===2&&o.isArray(arguments[1]))?arguments[1]:this.toArray(arguments,1);
return t.replace(/\{(\d+)\}/g,function(u,v){return typeof s[v]!=="undefined"?String(s[v]):u;
});},each:function(t,s){var u,v;if(o.isString(t)){t=t.split(",");}if(o.isArray(t)){for(u=0;
u<t.length;u++){v=o.isString(t[u])?o.trim(t[u]):t[u];if(s.call(v,u,v)===false){break;
}}}else{for(u in t){if(t.hasOwnProperty(u)){if(s.call(t[u],u,t[u])===false){break;
}}}}},event:function(s,u,t){if(o.isFunction(s)){s.call(u,t);}},donothing:function(){},expectOpts:function(s,t){if((s?s.length:0)<t){throw ({name:"AssertionError",type:"iq",message:o.format("Expected to receive at least {0} argument",t.toString())});
}},formatAssert:function(s,u,t){return !u?"":(s?s+": ":"")+o.format(u,o.isArray(t)?t:o.toArray(arguments,2));
}};n=function(s){i();o.extend(this,o.extend(null,h,s,true));this.clear();};n.prototype={constructor:n,test:function(w,s,t){var v=this,u=!!t,y={name:w,desc:u?s:"",func:u?t:s,debug:v.debug,showPassed:v.showPassed},x=new l(y);
v.add(x);return v;},add:function(u){var t=this;function s(v){t.tests.push(v);v.group=t;
v.id=t.tests.length;}if(u.constructor===n){o.each(u.tests,function(w,v){s(v);});}else{if(u.constructor===l){s(u);
}}return t;},run:function(w,s,u){var t,v=this;o.each(v.tests,function(x,y){y.reset();
});o.event(v.groupStart,v,o.filter(v,"name,desc"));o.each(v.tests,function(z,B){var x=o.extend({},B.assert,{test:B}),A=o.extend({},B.refute,{test:B});
o.event(B.testStart,B,o.filter(B,"name"));if(B.debug){B.func.call(B,x,A);}else{try{B.func.call(B,x,A);
}catch(y){B.testerror(o.format("An error occurred in your test code: {0}",y),true);
}}B._lastPromise=B.promise;B._allPass=true;t=function(C){if(C.promise!==C._lastPromise){C._lastPromise=C.promise;
C._lastPromise.then(function(){t(C);},function(D){C.testerror(D,true);t(C);});return;
}if(!o.isBool(C.passed)){C.passed=(C.count===C.countPassed);}C._allPass&=C.passed;
o.event(C.testEnd,C,o.filter(C,"count,passed"));if(C===v.tests[v.tests.length-1]){if(o.isBool(C.passed)){v.passed=C._allPass;
}o.event(v.groupEnd,v,o.filter(C,"passed"));}};B.promise.then(function(){t(B);},function(C){B.testerror(C,true);
t(B);});});},then:function(u,s){if(o.isFunction(u)){this.promise=this.promise.then.apply(this.promise,o.toArray(arguments));
return this;}else{var t=new n(this);this.promise=this.promise.then(function(){t.test(u,s);
return t;},function(){alert("debug: failback called on a group");});return t;}},configure:function(t){if(typeof t==="string"){t={name:t};
}var s=o.extend({},h);o.extend(s,t,true);o.extend(this,s);return this;},reset:function(){this.promise=q.defer();
this.passed=null;return this;},clear:function(){this.tests=[];this.reset();return this;
},groupStart:o.donothing,groupEnd:o.donothing};l=function(t){var s=this;o.extend(s,m);
o.extend(s,t,true);s.id=null;s.group=null;s.reset();};l.prototype={constructor:l,impl:{},reset:function(){o.extend(this,{promise:q.defer(),results:[],count:0,countPassed:0,countFailed:0,debugCount:0,nextThen:[],cbPromise:null,resolver:null,stopped:false,passed:null});
this.promise.resolve();},nextIsProblemAssertion:function(){return this.debug&&!this.stopped&&this.debugCount===this.count-1;
},timeout:function(u){var s=this,t=s.timeoutSeconds;s.then(function(){s.timeoutSeconds=u;
});s.afterNext(function(){s.timeoutSeconds=t;});},configure:function(t){if(typeof t==="string"){t={name:t};
}var s=o.extend({},m);o.extend(s,this,t,true);o.extend(this,s);},then:function(s,u){var v=this,t=u||function(y){v.testerror(y,false);
},x=v.promise,w=q.defer();w.then(function(){try{if(v.nextIsProblemAssertion()){;}s();
}catch(y){v.testerror("An error occurred during a 'then' clause of an assertion: "+String(y),true);
}},t);v.promise=w;q.chain(x,w);return v;},afterNext:function(s,t){this.nextThen.push({callback:s,errback:t});
},startTest:function(s){this.count++;o.event(this.itemStart,this,o.extend({},s,{count:this.count}));
this.itemRunning=true;},endTest:function(t){var s=t;if(!this.itemRunning){this.testerror("Error: test was not running when endTest called: "+t.desc);
return;}if(!t.passed){s=this.addResult(t);this.countFailed++;}else{this.countPassed++;
}this.itemRunning=false;o.event(this.itemEnd,this,s);},queueBooleanTest:function(v,t,s,u){return this.queueTest(function(){var w=v.apply(null,o.toArray(arguments));
if(w.passed===u){throw ({name:"AssertionError",type:"iq",message:o.format(w.err.replace("{not}","{0}"),u?"not ":"")});
}},t,s);},queueTest:function(A,t,s){var y=this,v,u=t.split(".")[1],z=c[u].args,x,w,B,D,C=[];
if(y.stopped){return y;}if(y.cbPromise){x=true;w=w||q.defer();if(z===1){v=0;}else{if(s[0]&&!s[1]){v=1;
}else{if(s[1]&&!s[0]){v=0;}else{y.testerror(o.format("I couldn't figure out what to do with your magic callback. For this test you may need to define it explicitly.[{0}] {1}",t,d(s)));
return;}}}y.cbPromise.then(function(G){s[v]=G;},function(G){w.reject("The callback failed. "+(G?o.format("Reason: {0}",String(G)):""));
});C.push(y.cbPromise);y.cbPromise=null;}if(u==="resolves"&&!q.isPromise(s[0])){throw ("The argument passed to 'resolves' was not a promise.");
}o.each(s,function(H,G){if(q.isPromise(G)){w=w||q.defer();if(H===0&&x){w.reject("You're using magic callback but you've also defined a promise as the first argument of your assert.");
}G.then(function(I){s[H]=I;});C.push(G);}});y.then(function(){y.startTest({desc:d(t,s),assertion:t});
});if(C.length){C.push(y.promise);y.promise=y.timeoutSeconds?r(w.promise,y.timeoutSeconds*1000):w.promise;
q.chain(q.all(C),w);}B=q.defer();D=y.promise;y.promise=B.promise;D.then(function F(G){if(y.runTest.call(y,A,t,s)){B.resolve();
}else{B.reject("The test failed");}},function E(G){if(y.itemRunning){y.endTest({passed:false,desc:String(G)});
}});return y;},runTest:function(v,t,s){var w={assertion:t,err:"",passed:true};try{v.apply(null,s);
}catch(u){if(u.name!=="AssertionError"){if(this.debug){;v.apply(null,s);}else{this.debug=true;
u.message=(u.message||u.type)+". Debugging has been enabled.";}}if(u.type==="iq"){u.message=o.format("[{0}] {1}",t,u.message);
}w.err=u.message;w.passed=false;}this.endTest(w);return w.passed;},addResult:function(u){var t=o.extend({},u),s=t.passed?"passed":"failed";
t.count=this.count;t.fulltext=o.format("Test #{0} {1}{2}{3}",this.count,s,t.passed?"":": "+u.err,u.desc?o.format(' in test "{0}"',u.desc):"");
this.results.push(t);return t;},testerror:function(t,s){var u=this;if(u.stopped){return;
}u.debugCount=u.count;u.stopped=true;u.passed=false;o.event(u.log,u.group,o.format("{0}. {1}",String(t),s?"Debugging is enabled if you start again.":""));
if(s){u.debug=true;}},callback:function(w,x){var u=this,v=x||u.timeoutSeconds,s=q.defer();
u.cbPromise=v?r(s,v*1000):s;return function(){var y;if(!w){y=true;}else{if(u.debug){y=w.apply(this,o.toArray(arguments));
}else{try{y=w.apply(this,o.toArray(arguments));}catch(t){u.testerror("An error occurred in your callback(): "+String(t),true);
s.reject(y);return;}}}s.resolve(y);};},backpromise:function(x,s,A){var v=q.defer(),y=this,z=A||y.timeoutSeconds,u=function(){var B;
if(y.debug){B=s.apply(this,o.toArray(arguments));}else{try{B=s.apply(this,o.toArray(arguments));
}catch(t){y.testerror("An error occurred in your backpromise() callback: "+t,true);
v.reject(B);return;}}v.resolve(B);};if(y.debug){x.call(y,u);}else{try{x.call(y,u);
}catch(w){y.testerror("An error occurred in your backpromise() function: "+w,true);
v.reject();return;}}return z?r(v,z*1000):v;},testStart:o.donothing,testEnd:o.donothing,itemStart:o.donothing,itemEnd:o.donothing,log:o.donothing};
return{configure:function(t){var s=new n(t);return s;},test:function(){var s=new n(this);
return s.test.apply(s,o.toArray(arguments));},extend:function(s){k.push(s);},impl:{TestGroup:n,Test:l,Assert:b,utility:o}};
});}(typeof define==="function"?define:function(a,b){if(typeof module!=="undefined"){module.exports=b(require("./when"),require("./timeout"),require("./buster-assertions"),require("./trewtech.utils"));
}else{if(!this.iqtest_assertions){this.iqtest_assertions=[];}this.iqtest=b(this.common.utils,this.when,this.when_timeout,this.iqtest_assertions,this.buster?this.buster.assert:null);
}}));