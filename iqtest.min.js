/*
IqTest: A javascript testing framework that promises to be easy

(c) 2012 James Treworgy
MIT License
*/

(function(a){a(["./iqtest"],function(p,q,k,e){var o,l,n,b,h={name:"Unnamed Test Group",debug:false,showPassed:false},m={name:"",desc:"Unnamed Test",func:null,showPassed:false,timeoutSeconds:10,debug:false},f="same,equals,typeOf,defined,isNull,match,isObject,isFunction,exception,tagName,className,isTrue,isFalse",j=false,c={};
function d(t,s){var r=c[t.split(".")[1]].args;return r<s.length?String(s[r]):"an anonymous test";
}function g(u,s){var t=0,v=/^.*?Expected.*?([0-9]) argument[s]?\s*$/;try{s();}catch(r){t=v.test(r.message)?parseInt(RegExp.$1,10):0;
}c[u]={args:t};}function i(){var r,s;if(j){return;}k.push({truthy:function(u,t){o.expectOpts(arguments,1);
return{passed:!!u,err:o.formatAssert(t,"The object {0} is {not}truthy",String(u))};
}});s=l.prototype;r=buster.assertions;o.each(["assert","refute"],function(u,v){var t={};
o.each(f.split(","),function(w,x){g(x,r[v][x]);t[x]=function(){var y=((this.test&&this.test instanceof l)?this.test:this);
return y.queueTest(r[v][x],v+"."+x,o.toArray(arguments));};});o.each(k,function(w,x){o.each(x,function(z,y){if(!t[z]){g(z,y);
t[z]=function(){var A=((this.test&&this.test instanceof l)?this.test:this);return A.queueBooleanTest(y,v+"."+z,o.toArray(arguments),v==="refute");
};}});});if(v==="assert"){o.extend(s,t);}o.each(["backpromise","callback","then"],function(w,x){t[x]=function(){return this.test[x].apply(this.test,o.toArray(arguments));
};});s[v]=function(x,w){return s[v].truthy.apply(this,o.toArray(arguments));};o.extend(s[v],t);
j=true;});}o={extend:function(A){var x,y,z,s,v=arguments.length,t=o.isBool(arguments[v-1]),u=t?v-2:v-1,r=!A,w=t?arguments[u+1]:false;
A=A||{};z=o.toArray(arguments,1,u+1);for(s=0;s<z.length;s++){y=z[s];for(x in y){if(y.hasOwnProperty(x)&&(r||!w||A.hasOwnProperty(x))){A[x]=y[x];
}}r=false;}return A;},filter:function(s,u){var t={},r=o.isArray(u)?u:u.split(",");
o.each(r,function(v,w){t[w]=s[w];});return t;},toArray:function(r,s,t){return Array.prototype.slice.call(r,s||0,t);
},isArray:function(r){return r&&r.constructor===Array;},isFunction:function(r){return typeof r==="function";
},isString:function(r){return typeof r==="string";},isBool:function(r){return typeof r==="boolean";
},trim:function(r){return r.replace(/^\s\s*/,"").replace(/\s\s*$/,"");},split:function(t,r){var s=[];
o.each(t.split(t,r),function(v,u){s.push(o.trim(u));});return s;},format:function(s){var r=(arguments.length===2&&o.isArray(arguments[1]))?arguments[1]:this.toArray(arguments,1);
return s.replace(/\{(\d+)\}/g,function(t,u){return typeof r[u]!=="undefined"?String(r[u]):t;
});},each:function(s,r){var t,u;if(o.isString(s)){s=s.split(",");}if(o.isArray(s)){for(t=0;
t<s.length;t++){u=o.isString(s[t])?o.trim(s[t]):s[t];if(r.call(u,t,u)===false){break;
}}}else{for(t in s){if(s.hasOwnProperty(t)){if(r.call(s[t],t,s[t])===false){break;
}}}}},event:function(r,t,s){if(o.isFunction(r)){r.call(t,s);}},donothing:function(){},expectOpts:function(r,s){if((r?r.length:0)<s){throw ({name:"AssertionError",type:"iq",message:o.format("Expected to receive at least {0} argument",s.toString())});
}},formatAssert:function(r,t,s){return !t?"":(r?r+": ":"")+s?o.format(t,o.isArray(s)?s:o.toArray(arguments,2)):"";
}};n=function(r){i();this.tests=[];o.extend(this,o.extend(null,h,r,true));this.promise=p.defer();
this.passed=null;};n.prototype={constructor:n,test:function(v,r,s){var u=this,t=!!s,x={name:v,desc:t?r:"",func:t?s:r,debug:u.debug,showPassed:u.showPassed},w=new l(x);
u.tests.push(w);w.group=u;w.id=u.tests.length;return u;},run:function(v,r,t){var s,u=this;
o.each(u.tests,function(w,x){x.reset();});o.event(u.groupStart,u,o.filter(u,"name,desc"));
o.each(u.tests,function(y,A){var w=o.extend({},A.assert,{test:A}),z=o.extend({},A.assert,{test:A});
o.event(A.testStart,A,o.filter(A,"name"));if(A.debug){A.func.call(A,w,z);}else{try{A.func.call(A,w,z);
}catch(x){A.testerror(o.format("An error occurred in your test code: {0}",x),true);
}}A._lastPromise=A.promise;A._allPass=true;s=function(){if(A.promise!==A._lastPromise){A._lastPromise=A.promise;
A._lastPromise.then(s,s);return;}if(!o.isBool(A.passed)){A.passed=(A.count===A.countPassed);
}A._allPass&=A.passed;o.event(A.testEnd,A,o.filter(A,"count,passed"));if(A===u.tests[u.tests.length-1]){if(o.isBool(A.passed)){u.passed=A._allPass;
}o.event(u.groupEnd,u,o.filter(A,"passed"));}};A.promise.then(s,s);});},then:function(t,r){if(o.isFunction(t)){this.promise=this.promise.then.apply(this.promise,o.toArray(arguments));
return this;}else{var s=new n(this);this.promise=this.promise.then(function(){s.test(t,r);
return s;},function(){alert("debug: failback called on a group");});return s;}},configure:function(s){var r=o.extend({},h);
o.extend(r,s,true);o.extend(this,r);return this;},groupStart:o.donothing,groupEnd:o.donothing};
l=function(s){var r=this;o.extend(r,m);o.extend(r,s,true);r.id=null;r.group=null;
r.reset();};l.prototype={constructor:l,impl:{},reset:function(){o.extend(this,{promise:p.defer(),results:[],count:0,countPassed:0,countFailed:0,nextThen:[],cbPromise:null,resolver:null,stopped:false,passed:null});
this.promise.resolve();},timeout:function(t){var r=this,s=r.timeoutSeconds;r.then(function(){r.timeoutSeconds=t;
});r.afterNext(function(){r.timeoutSeconds=s;});},configure:function(s){var r=o.extend({},m);
o.extend(r,this,s,true);o.extend(this,r);},then:function(r,t){var v=this,u=function(w){v.testerror(w,false);
};function s(w,x){v.promise=v.promise.then(w,x||u);}s(r,t);if(v.afterNext.length>0){o.each(function(w,x){s(x.callback,x.errback);
});v.afterNext=[];}return v;},afterNext:function(r,s){this.nextThen.push({callback:r,errback:s});
},startTest:function(r){this.count++;o.event(this.itemStart,this,o.extend({},r,{count:this.count}));
this.itemRunning=true;},endTest:function(s){var r=s;if(!s.passed){r=this.addResult(s);
this.countFailed++;}else{this.countPassed++;}this.itemRunning=false;o.event(this.itemEnd,this,r);
},queueBooleanTest:function(u,s,r,t){return this.queueTest(function(){var v=u.apply(null,o.toArray(arguments));
if(v.passed===t){throw ({name:"AssertionError",type:"iq",message:o.format(v.err.replace("{not}","{0}"),t?"not ":"")});
}},s,r);},queueTest:function(y,s,r){var w=this,t,x=c[s.split(".")[1]].args,v,u=p.defer(),z=[];
w.promise.then(function(){w.startTest({desc:d(s,r),assertion:s});},function(A){u.reject(A);
});if(w.cbPromise){v=true;if(x===1){t=0;}else{if(r[0]&&!r[1]){t=1;}else{if(r[1]&&!r[0]){t=0;
}else{w.testerror(o.format("I couldn't figure out what to do with your magic callback. For this test you may need to define it explicitly.[{0}] {1}",s,d(r)));
return;}}}w.cbPromise.then(function(A){r[t]=A;},function(A){u.reject("The callback failed. "+(A?o.format("Reason: {0}",String(A)):""));
});z.push(w.cbPromise);w.cbPromise=null;}o.each(r,function(B,A){if(p.isPromise(A)){if(B===0&&v){u.reject("You're using magic callback but you've also defined a promise as the first argument of your assert.");
}A.then(function(C){r[B]=C;});z.push(A);}});if(z.length){z.push(w.promise);w.promise=p.all(z);
}w.then(function(){if(w.runTest.call(w,y,s,r)){u.resolve();}else{u.reject("The test failed.");
}},function(A){u.reject(A);});w.promise=q(u.promise,w.timeoutSeconds*1000);w.resolver=u.resolver;
return w;},runTest:function(u,s,r){var v={assertion:s,err:"",passed:true};try{u.apply(null,r);
}catch(t){if(t.name!=="AssertionError"){if(this.debug){;u.apply(null,r);}else{this.debug=true;
t.message=(t.message||t.type)+". Debugging has been enabled.";}}if(t.type==="iq"){t.message=o.format("[{0}] {1}",s,t.message);
}v.err=t.message;v.passed=false;}this.endTest(v);return v.passed;},addResult:function(t){var s=o.extend({},t),r=s.passed?"passed":"failed";
s.count=this.count;s.fulltext=o.format("Test #{0} {1}{2}{3}",this.count,r,s.passed?"":": "+t.err,t.desc?o.format(' in test "{0}"',t.desc):"");
this.results.push(s);return s;},testerror:function(s,r){var u=this;if(u.resolver){try{u.resolver.reject(s);
}catch(t){}u.resolver=null;}if(u.stopped){return;}u.stopped=true;u.passed=false;o.event(u.log,u.group,o.format("{0}. {1}",String(s),r?"Debugging is enabled if you start again.":""));
if(r){u.debug=true;}},callback:function(v,w){var s=this,u=w||s.timeoutSeconds,r=p.defer();
s.cbPromise=u?q(r,u*1000):r;return function(){var x;if(!v){x=true;}else{if(s.debug){x=v.apply(this,o.toArray(arguments));
}else{try{x=v.apply(this,o.toArray(arguments));}catch(t){s.testerror("An error occurred in your callback(): "+t,true);
r.reject(x);return;}}}r.resolve(x);};},backpromise:function(w,r,z){var u=p.defer(),x=this,y=z||x.timeoutSeconds,s=function(){var A;
if(x.debug){A=r.apply(this,o.toArray(arguments));}else{try{A=r.apply(this,o.toArray(arguments));
}catch(t){x.testerror("An error occurred in your backpromise() callback: "+t,true);
u.reject(A);return;}}u.resolve(A);};if(x.debug){w.call(x,s);}else{try{w.call(x,s);
}catch(v){x.testerror("An error occurred in your backpromise() function: "+v,true);
u.reject();return;}}return y?q(u,y*1000):u;},testStart:o.donothing,testEnd:o.donothing,itemStart:o.donothing,itemEnd:o.donothing,log:o.donothing};
return{test:function(){var r=new n(this);return r.test.apply(r,o.toArray(arguments));
},extend:function(r){k.push(r);},impl:{TestGroup:n,Test:l,Assert:b,utility:o}};});
}(typeof define==="function"?define:function(a,b){if(typeof module!=="undefined"){module.exports=b(require("./when"),require("./timeout"),require("./buster-assertions"));
}else{if(!this.iqtest_assertions){this.iqtest_assertions=[];}this.iqtest=b(this.when,this.when_timeout,this.iqtest_assertions,this.buster?this.buster.assert:null);
}}));